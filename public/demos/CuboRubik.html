<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rubik con THREE.js</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #111;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body></body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000,
    );
    camera.position.set(3.5, 3.5, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const COLORS = {
      right: 0xff0000, 
      left: 0xff8c00,
      up: 0xffffff, 
      down: 0xffff00, 
      front: 0x009e60, 
      back: 0x0051ba, 
      black: 0x111111,
    };

    const rubik = new THREE.Group();
    const size = 1; 
    const gap = 0.04; 
    const cubeletSize = size - gap;

    const positions = [-1, 0, 1];
    for (let xi of positions) {
      for (let yi of positions) {
        for (let zi of positions) {
          const geom = new THREE.BoxGeometry(
            cubeletSize,
            cubeletSize,
            cubeletSize,
          );
          const materials = [
            new THREE.MeshBasicMaterial({
              color: xi === 1 ? COLORS.right : COLORS.black,
            }), 
            new THREE.MeshBasicMaterial({
              color: xi === -1 ? COLORS.left : COLORS.black,
            }), 
            new THREE.MeshBasicMaterial({
              color: yi === 1 ? COLORS.up : COLORS.black,
            }), 
            new THREE.MeshBasicMaterial({
              color: yi === -1 ? COLORS.down : COLORS.black,
            }), 
            new THREE.MeshBasicMaterial({
              color: zi === 1 ? COLORS.front : COLORS.black,
            }), 
            new THREE.MeshBasicMaterial({
              color: zi === -1 ? COLORS.back : COLORS.black,
            }), 
          ];

          const cubelet = new THREE.Mesh(geom, materials);
          cubelet.position.set(xi * size, yi * size, zi * size);
          rubik.add(cubelet);
        }
      }
    }

    scene.add(rubik);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.8;
    controls.zoomSpeed = 1.0;
    controls.minDistance = 4;
    controls.maxDistance = 12;
    controls.target.set(0, 0, 0);

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</html>
